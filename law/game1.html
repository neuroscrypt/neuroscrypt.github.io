<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Interactive Pipeline Visual</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#020617;
      --bg2:#020314;
      --panel:#02010a;
      --cyan:#22d3ee;
      --cyan-soft:#38bdf8;
      --cyan-deep:#0ea5e9;
      --red:#fb7185;
      --red-deep:#991b1b;
      --red-soft:#fecaca;
      --grid:#0b1220;
    }

    * {
      margin:0;
      padding:0;
      box-sizing:border-box;
    }

    body {
      font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",system-ui,sans-serif;
      min-height:100vh;
      background:
        radial-gradient(circle at top,#0f172a 0%,#020617 45%,#000000 100%);
      color:#e5e7eb;
      overflow:hidden;
    }

    .root {
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px 16px;
    }

    .frame {
      position:relative;
      width:100%;
      max-width:1360px;
      aspect-ratio:16/9;
      border-radius:32px;
      overflow:hidden;
      background:radial-gradient(circle at center,#020617,#020314 50%,#000000 100%);
      box-shadow:0 40px 120px rgba(0,0,0,0.9);
    }

    /* сетка на фоне */

    .frame::before {
      content:"";
      position:absolute;
      inset:-60px;
      background-image:
        linear-gradient(to right,rgba(15,23,42,0.55) 1px,transparent 1px),
        linear-gradient(to bottom,rgba(15,23,42,0.55) 1px,transparent 1px);
      background-size:64px 64px;
      opacity:0.35;
      pointer-events:none;
    }

    /* центральная панель под WebGL */

    .center-panel {
      position:absolute;
      inset:10% 12%;
      border-radius:32px;
      background:radial-gradient(circle at center,#020617 0%,#000000 55%,#020617 100%);
      box-shadow:
        0 0 110px rgba(15,23,42,1),
        0 -40px 90px rgba(0,0,0,0.8);
      overflow:hidden;
    }

    #glCanvas {
      width:100%;
      height:100%;
      display:block;
    }

    /* боковые колонки */

    .column {
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      z-index:4;
      display:flex;
      flex-direction:column;
      gap:22px;
    }

    .column.left {
      left:5.5%;
    }

    .column.right {
      right:5.5%;
    }

    /* левый столбец: источники */

    .source-icon {
      position:relative;
      width:70px;
      height:70px;
      border-radius:22px;
      border:1px solid rgba(56,189,248,0.75);
      background:
        radial-gradient(circle at 25% 20%,rgba(56,189,248,0.35),rgba(15,23,42,0.95));
      box-shadow:
        0 0 22px rgba(56,189,248,0.7),
        0 0 80px rgba(8,47,73,0.9);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      overflow:hidden;
      transition:transform 0.18s ease,box-shadow 0.18s ease,border-color 0.18s ease;
    }

    .source-icon svg {
      width:54%;
      height:54%;
      fill:none;
      stroke:var(--cyan);
      stroke-width:2.1;
      stroke-linecap:round;
      stroke-linejoin:round;
    }

    .source-icon::after {
      /* мягкое гало вокруг */
      content:"";
      position:absolute;
      inset:-28%;
      border-radius:26px;
      background:radial-gradient(circle at center,rgba(56,189,248,0.45),transparent 60%);
      opacity:0.0;
      pointer-events:none;
      transition:opacity 0.2s ease;
    }

    .source-icon:hover {
      transform:translateY(-2px) scale(1.03);
      box-shadow:
        0 0 35px rgba(56,189,248,0.95),
        0 0 120px rgba(37,99,235,0.9);
    }

    .source-icon:hover::after,
    .source-icon.active::after {
      opacity:0.65;
    }

    .source-icon.active {
      border-color:#e0f2fe;
    }

    /* правый столбец: цели */

    .target-icon {
      position:relative;
      width:64px;
      height:82px;
      border-radius:22px;
      background:
        radial-gradient(circle at 30% 22%,rgba(252,165,165,0.96),rgba(127,29,29,0.96) 55%,rgba(15,23,42,0.98) 100%);
      box-shadow:
        0 0 28px rgba(248,113,113,0.9),
        0 0 80px rgba(248,113,113,0.75);
      overflow:hidden;
      cursor:pointer;
      transition:transform 0.18s ease,box-shadow 0.18s ease;
    }

    .target-icon:hover {
      transform:translateY(-2px) scale(1.03);
      box-shadow:
        0 0 40px rgba(248,250,252,1),
        0 0 100px rgba(248,113,113,1);
    }

    .target-icon::before {
      /* силуэт головы */
      content:"";
      position:absolute;
      left:50%;
      top:26%;
      width:30px;
      height:30px;
      transform:translateX(-50%);
      border-radius:50%;
      background:rgba(0,0,0,0.55);
      box-shadow:0 0 18px rgba(0,0,0,0.8);
    }

    .target-icon::after {
      /* корпус */
      content:"";
      position:absolute;
      left:50%;
      top:55%;
      width:40px;
      height:32px;
      transform:translateX(-50%);
      border-radius:50% 50% 14px 14px;
      background:rgba(0,0,0,0.65);
    }

    .target-icon span.cross {
      position:absolute;
      inset:8px;
      border-radius:16px;
      border:2px solid rgba(254,242,242,0.35);
      box-shadow:0 0 18px rgba(254,202,202,0.7);
      pointer-events:none;
    }

    .target-icon span.cross::before,
    .target-icon span.cross::after {
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:rgba(248,250,252,0.45);
    }

    .target-icon span.cross::before {
      width:100%;
      height:1px;
    }

    .target-icon span.cross::after {
      width:1px;
      height:100%;
    }

    /* вспышка при попадании «пакета» */

    .target-icon.hit {
      animation:targetHit 0.3s ease-out;
    }

    @keyframes targetHit {
      0% {
        box-shadow:
          0 0 10px rgba(251,113,133,0.7),
          0 0 40px rgba(248,113,113,0.8);
        transform:scale(1.0);
      }
      40% {
        box-shadow:
          0 0 40px rgba(255,255,255,1),
          0 0 110px rgba(248,113,113,1);
        transform:scale(1.08);
      }
      100% {
        box-shadow:
          0 0 28px rgba(248,113,113,0.9),
          0 0 80px rgba(248,113,113,0.75);
        transform:scale(1.0);
      }
    }

    @media (max-width:1000px) {
      .frame {
        border-radius:24px;
      }
      .center-panel {
        inset:12% 13%;
      }
    }

    @media (max-width:800px) {
      .frame {
        aspect-ratio:auto;
        height:80vh;
      }
      .center-panel {
        inset:18% 12%;
      }
      .column.left {
        left:4%;
      }
      .column.right {
        right:4%;
      }
      .source-icon,
      .target-icon {
        transform:scale(0.9);
      }
    }

    @media (max-width:620px) {
      .frame {
        height:90vh;
      }
      .center-panel {
        inset:22% 10%;
      }
      .column {
        gap:16px;
      }
      .source-icon,
      .target-icon {
        transform:scale(0.8);
      }
    }
  </style>
</head>
<body>
<div class="root">
  <div class="frame">
    <!-- центральная область WebGL -->
    <div class="center-panel">
      <canvas id="glCanvas"></canvas>
    </div>

    <!-- левый столбец: источники -->
    <div class="column left">
      <button class="source-icon video" data-mode="0" aria-label="">
        <svg viewBox="0 0 60 60">
          <rect x="13" y="15" width="30" height="20" rx="6" ry="6" />
          <polygon points="30,20 38,25 30,30" />
          <rect x="16" y="19" width="3" height="3" />
          <rect x="16" y="24" width="3" height="3" />
          <rect x="16" y="29" width="3" height="3" />
        </svg>
      </button>

      <button class="source-icon audio" data-mode="1" aria-label="">
        <svg viewBox="0 0 60 60">
          <path d="M12 30 Q16 17 20 30 T28 30 T36 30 T48 30" />
          <path d="M16 36 v-12 M20 38 v-16 M24 36 v-12 M28 40 v-20 M32 36 v-12 M36 38 v-16 M40 36 v-12" />
        </svg>
      </button>

      <button class="source-icon chat" data-mode="2" aria-label="">
        <svg viewBox="0 0 60 60">
          <rect x="12" y="16" width="32" height="20" rx="7" ry="7" />
          <polygon points="26,36 21,40 21,35" />
          <circle cx="21" cy="26" r="2.3" />
          <circle cx="29" cy="26" r="2.3" />
          <circle cx="37" cy="26" r="2.3" />
        </svg>
      </button>
    </div>

    <!-- правый столбец: цели -->
    <div class="column right">
      <div class="target-icon">
        <span class="cross"></span>
      </div>
      <div class="target-icon">
        <span class="cross"></span>
      </div>
      <div class="target-icon">
        <span class="cross"></span>
      </div>
    </div>
  </div>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.161.0/build/three.module.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('glCanvas');
    const panel = document.querySelector('.center-panel');
    if (!canvas || !panel || !window.THREE) return;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(36, 1, 0.1, 100);
    camera.position.set(0, 0, 18);

    const ambient = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(5, 7, 10);
    scene.add(dir);

    const group = new THREE.Group();
    scene.add(group);

    // GLSL шейдер для светящейся трубки
    const uniforms = {
      uTime: { value: 0 },
      uProgress: { value: 0.0 },
      uMode: { value: 0.0 },
      uBoost: { value: 0.0 }
    };

    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fragmentShader = `
      precision highp float;
      varying vec2 vUv;
      uniform float uTime;
      uniform float uProgress;
      uniform float uMode;
      uniform float uBoost;

      float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7)))*43758.5453123); }

      void main() {
        float x = vUv.x;
        float y = vUv.y;

        float dist = distance(vec2(0.5,0.5), vec2(x,y));
        float tube = smoothstep(0.75, 0.4, dist);

        // бегущая несущая волна
        float carrier = 0.5 + 0.5 * sin((x*12.0 - uTime*3.0) + uMode*1.7);
        float carrierBand = smoothstep(0.55, 0.85, carrier) * tube;

        // псевдо-биты как вспышки
        float gx = floor(x * 32.0);
        float gy = floor(y * 14.0);
        float rnd = hash(vec2(gx, gy) + floor(uTime*4.0));
        float bitMask = step(0.93, rnd) * tube;

        // зона «фокуса» (опасный блок) ближе к правому краю
        float focusPos = 0.55 + 0.3 * uProgress;
        float focus = 1.0 - smoothstep(0.0, 0.22, abs(x - focusPos));

        // базовый цвет
        vec3 baseDark = vec3(0.01, 0.07, 0.16);
        vec3 baseCyan = vec3(0.06, 0.40, 0.76);
        vec3 col = mix(baseDark, baseCyan, tube);

        // волны
        vec3 waveCol = mix(vec3(0.12,0.75,1.0), vec3(0.08,0.55,0.95), uMode/2.0);
        col += waveCol * carrierBand * 0.7;

        // «символы модуляции» — полосы и точки
        float stripes = smoothstep(0.0, 0.2, abs(sin((y*24.0 + x*10.0) - uTime*2.0)));
        col += vec3(0.05,0.35,0.75) * stripes * tube * 0.35;

        // псевдо-0/1
        vec3 bitColor = vec3(0.4,0.9,1.0);
        col += bitColor * bitMask * (0.4 + 0.8*uBoost);

        // красное смешение в фокусе
        vec3 riskColor = vec3(1.0,0.33,0.24);
        float riskPower = focus * (0.55 + 0.35*uBoost);
        col = mix(col, riskColor, riskPower);

        // подсветка краёв
        float edge = smoothstep(0.3, 0.02, dist);
        col += vec3(0.12,0.55,1.0) * edge * 0.4;

        gl_FragColor = vec4(col, tube*0.96);
      }
    `;

    const tubeGeo = new THREE.CylinderGeometry(2.6, 2.6, 9.6, 96, 1, true);
    const tubeMat = new THREE.ShaderMaterial({
      uniforms,
      vertexShader,
      fragmentShader,
      side: THREE.DoubleSide,
      transparent: true
    });

    const tube = new THREE.Mesh(tubeGeo, tubeMat);
    tube.rotation.z = Math.PI / 2;
    group.add(tube);

    // крышки
    const capGeo = new THREE.CircleGeometry(2.6, 64);
    const capMat = new THREE.MeshStandardMaterial({
      color: 0x020617,
      emissive: 0x0ea5e9,
      emissiveIntensity: 0.8,
      transparent:true,
      opacity:0.95,
      metalness:0.2,
      roughness:0.35
    });

    const capL = new THREE.Mesh(capGeo, capMat.clone());
    capL.position.set(-4.9, 0, 0);
    capL.rotation.y = Math.PI / 2;
    group.add(capL);

    const capR = new THREE.Mesh(capGeo, capMat.clone());
    capR.position.set(4.9, 0, 0);
    capR.rotation.y = -Math.PI / 2;
    group.add(capR);

    // «пакеты данных», бегущие через трубку
    const packetGeo = new THREE.SphereGeometry(0.13, 20, 20);
    const packets = [];
    const PACKET_COUNT = 130;

    for (let i = 0; i < PACKET_COUNT; i++) {
      const mat = new THREE.MeshStandardMaterial({
        color: 0x93c5fd,
        emissive: 0x38bdf8,
        emissiveIntensity: 1.1,
        metalness:0.3,
        roughness:0.2
      });
      const m = new THREE.Mesh(packetGeo, mat);
      m.position.set(
        -4.5 + Math.random()*9.0,
        (Math.random()-0.5)*0.9,
        (Math.random()-0.5)*0.9
      );
      m.userData.speed = 0.025 + Math.random()*0.03;
      m.userData.offset = Math.random()*Math.PI*2;
      group.add(m);
      packets.push(m);
    }

    // управление размером
    function resize() {
      const rect = panel.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      if (!width || !height) return;
      renderer.setSize(width, height, false);
      camera.aspect = width/height;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    let start = performance.now();
    let pointerX = 0.5;
    let pointerY = 0.5;
    let boost = 0;
    let mode = 0;

    window.addEventListener('pointermove', (e) => {
      pointerX = e.clientX / window.innerWidth;
      pointerY = e.clientY / window.innerHeight;
    });

    // левый столбец: выбор режима
    const sources = document.querySelectorAll('.source-icon');
    sources.forEach(btn => {
      btn.addEventListener('click', () => {
        sources.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = Number(btn.dataset.mode) || 0;
        uniforms.uMode.value = mode;
        boost = 1.0;
      });
    });
    if (sources[0]) sources[0].classList.add('active');

    const targets = Array.from(document.querySelectorAll('.target-icon'));

    function randomHit() {
      if (!targets.length) return;
      const t = targets[Math.floor(Math.random()*targets.length)];
      t.classList.add('hit');
      setTimeout(() => t.classList.remove('hit'), 260);
    }

    function render() {
      const now = performance.now();
      const t = (now - start) / 1000;

      uniforms.uTime.value = t;

      // прогресс по трубке (фокус движется)
      const auto = (t*0.1) % 1;
      uniforms.uProgress.value = 0.35 + auto*0.5;

      // boost затухает
      boost *= 0.94;
      uniforms.uBoost.value = boost;

      // лёгкое покачивание
      group.rotation.y = (pointerX-0.5)*0.5;
      group.rotation.x = (pointerY-0.5)*0.25;

      // движение пакетов
      for (let i=0;i<packets.length;i++) {
        const p = packets[i];
        const s = p.userData.speed * (1 + boost*2.2);
        p.position.x += s;
        p.position.y = Math.sin(t*1.6 + p.userData.offset)*0.6;
        if (p.position.x > 4.5) {
          // "попадание" в правую сторону
          if (Math.random() < 0.25) randomHit();
          p.position.x = -4.5;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  });
</script>
</body>
</html>
