<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Анализатор эмоций и позы</title>
  <style>
    /* Основной стиль страницы */
    body {
      margin: 0;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
    /* Скрываем видео */
    video#video {
      opacity: 0;
    }
    /* Фиксированная панель управления (350px x 870px) */
    #infoPanel {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 350px;
      height: 870px;
      background: rgba(255,255,255,0.97);
      padding: 10px 15px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      overflow-y: auto;
    }
    #infoPanel h2, #infoPanel h3 {
      margin: 5px 0;
      color: #444;
    }
    #infoPanel p, #infoPanel li, #infoPanel span {
      margin: 3px 0;
      font-size: 14px;
      color: #333;
      display: block;
    }
    #infoPanel ul {
      list-style: none;
      padding-left: 10px;
      margin: 0;
    }
    /* Секция управления Canvas – два ползунка */
    #canvasControls {
      margin-top: 10px;
    }
    #canvasControls label {
      font-size: 14px;
      margin-right: 5px;
    }
    #canvasControls input[type=range] {
      width: 90%;
      margin: 5px 0;
    }
    #canvasControls span {
      font-weight: bold;
      margin-left: 5px;
    }
    /* Секция переключения режима отрисовки лица */
    #faceRenderToggle {
      margin-top: 10px;
      text-align: center;
    }
    #faceRenderToggle button {
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: #f0f0f0;
    }
    /* Canvas размещён отдельно по центру страницы */
    canvas#overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 2px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      background: #fff;
    }
  </style>
  <!-- Подключение TensorFlow.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>
  <!-- Подключение face-api.js -->
  <script defer src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <!-- Подключение posenet -->
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
</head>
<body>
  <!-- Видео с веб-камеры (скрыто через opacity) -->
  <video id="video" width="1280" height="960" autoplay muted></video>
  <!-- Canvas вынесен отдельно и по умолчанию имеет размер 1280x960 -->
  <canvas id="overlay" width="1280" height="960"></canvas>

  <!-- Панель управления -->
  <div id="infoPanel">
    <h2>Информация</h2>
    <!-- Секция лица -->
    <div id="faceInfo">
      <h3>Лица</h3>
      <span id="faceCountSpan">Количество лиц: 0</span>
      <ul id="faceDetails">
        <!-- Каждое лицо будет описываться в отдельных span -->
      </ul>
    </div>
    <!-- Секция параметров позы -->
    <div id="poseInfo">
      <h3>Параметры позы</h3>
      <ul id="poseDetails">
        <!-- Каждый параметр позы в отдельном span -->
      </ul>
    </div>
    <!-- Секция управления размером Canvas -->
    <div id="canvasControls">
      <h3>Управление Canvas</h3>
      <label for="widthSlider">Ширина Canvas:</label>
      <input type="range" id="widthSlider" min="320" max="1920" value="1280">
      <span id="widthValue">1280</span> px
      <label for="heightSlider">Высота Canvas:</label>
      <input type="range" id="heightSlider" min="240" max="1440" value="960">
      <span id="heightValue">960</span> px
    </div>
    <!-- Кнопка переключения режима отрисовки лица -->
    <div id="faceRenderToggle">
      <button id="toggleModeButton">Режим: Рамка</button>
    </div>
  </div>

  <script defer>
    window.addEventListener('load', async () => {
      const video = document.getElementById('video');
      const canvas = document.getElementById('overlay');
      const ctx = canvas.getContext('2d');
      const faceCountSpan = document.getElementById('faceCountSpan');
      const faceDetailsEl = document.getElementById('faceDetails');
      const poseDetailsEl = document.getElementById('poseDetails');
      const widthSlider = document.getElementById('widthSlider');
      const heightSlider = document.getElementById('heightSlider');
      const widthValue = document.getElementById('widthValue');
      const heightValue = document.getElementById('heightValue');
      const toggleModeButton = document.getElementById('toggleModeButton');
      let posenetModel, faceRenderMode = "рамка";  // режим: "рамка" или "маска"

      // Порог стабильности для эмоций (5 кадров)
      const stabilityThreshold = 5;
      let stableEmotion = null;
      let currentEmotion = null;
      let stabilityCount = 0;

      // Переменные для стабилизации обновления панели (раз в 500 мс)
      let lastPanelUpdate = Date.now();
      let lastFaceResults = null;
      let lastPose = null;

      // Массив для последующего анализа данных
      const analysisData = [];

      // Сопоставление английских названий эмоций с русскими
      const emotionMapping = {
        angry: 'Злость',
        disgusted: 'Отвращение',
        fearful: 'Страх',
        happy: 'Счастье',
        neutral: 'Нейтрально',
        sad: 'Грусть',
        surprised: 'Удивление'
      };

      // Настройка веб-камеры
      async function setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
          video.srcObject = stream;
          return new Promise((resolve) => {
            video.onloadedmetadata = () => resolve(video);
          });
        } catch (error) {
          console.error("Ошибка доступа к веб-камере:", error);
        }
      }

      // Загрузка моделей face-api.js и posenet
      async function loadModels() {
        const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
        // Модели для детекции лица, эмоций и landmarks
        await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
        await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);
        await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
        posenetModel = await posenet.load();
      }

      // Переключение режима отрисовки лица
      toggleModeButton.addEventListener('click', () => {
        if (faceRenderMode === "рамка") {
          faceRenderMode = "маска";
          toggleModeButton.textContent = "Режим: Маска";
        } else {
          faceRenderMode = "рамка";
          toggleModeButton.textContent = "Режим: Рамка";
        }
      });

      // Функция обновления стабильного значения эмоции
      function updateEmotion(newEmotion) {
        if (currentEmotion === newEmotion) {
          stabilityCount++;
        } else {
          currentEmotion = newEmotion;
          stabilityCount = 1;
        }
        if (stabilityCount >= stabilityThreshold) {
          stableEmotion = currentEmotion;
        }
      }

      // Функция для генерации fallback данных позы, если видео не позволяет определить позу
      function getFallbackPose() {
        return {
          keypoints: [
            { part: "нос", score: 1, position: { x: canvas.width / 2, y: canvas.height / 4 } },
            { part: "левый глаз", score: 1, position: { x: canvas.width / 2 - 20, y: canvas.height / 4 - 10 } },
            { part: "правый глаз", score: 1, position: { x: canvas.width / 2 + 20, y: canvas.height / 4 - 10 } },
            { part: "левое ухо", score: 0.8, position: { x: canvas.width / 2 - 40, y: canvas.height / 4 } },
            { part: "правое ухо", score: 0.8, position: { x: canvas.width / 2 + 40, y: canvas.height / 4 } },
            { part: "левое плечо", score: 1, position: { x: canvas.width / 2 - 30, y: canvas.height / 2 } },
            { part: "правое плечо", score: 1, position: { x: canvas.width / 2 + 30, y: canvas.height / 2 } },
            { part: "левый локоть", score: 0.9, position: { x: canvas.width / 2 - 50, y: canvas.height / 2 + 40 } },
            { part: "правый локоть", score: 0.9, position: { x: canvas.width / 2 + 50, y: canvas.height / 2 + 40 } },
            { part: "левая кисть", score: 0.8, position: { x: canvas.width / 2 - 60, y: canvas.height / 2 + 80 } },
            { part: "правая кисть", score: 0.8, position: { x: canvas.width / 2 + 60, y: canvas.height / 2 + 80 } },
            { part: "левый таз", score: 1, position: { x: canvas.width / 2 - 20, y: canvas.height * 0.75 } },
            { part: "правый таз", score: 1, position: { x: canvas.width / 2 + 20, y: canvas.height * 0.75 } },
            { part: "левое колено", score: 0.9, position: { x: canvas.width / 2 - 20, y: canvas.height - 50 } },
            { part: "правое колено", score: 0.9, position: { x: canvas.width / 2 + 20, y: canvas.height - 50 } },
            { part: "левая лодыжка", score: 0.8, position: { x: canvas.width / 2 - 20, y: canvas.height - 10 } },
            { part: "правая лодыжка", score: 0.8, position: { x: canvas.width / 2 + 20, y: canvas.height - 10 } }
          ]
        };
      }

      // Функция обновления информации в панели, где каждый параметр оборачивается в отдельный <span>
      function updateInfoPanel(faceResults, pose) {
        // Обновление информации по лицам
        faceDetailsEl.innerHTML = "";
        if (faceResults && faceResults.length > 0) {
          faceCountSpan.textContent = "Количество лиц: " + faceResults.length;
          faceResults.forEach((result, index) => {
            const { x, y, width, height } = result.detection.box;
            // Каждый параметр лица в отдельном span
            const faceContainer = document.createElement('li');
            const spanId = document.createElement('span');
            spanId.textContent = `Лицо ${index + 1}`;
            const spanBox = document.createElement('span');
            spanBox.textContent = ` (Коорд. x:${Math.round(x)}, y:${Math.round(y)}; Размеры w:${Math.round(width)}, h:${Math.round(height)})`;
            faceContainer.appendChild(spanId);
            faceContainer.appendChild(spanBox);
            // Вывод каждого значения эмоции в свой span
            const expressions = result.expressions;
            for (let key in expressions) {
              const spanExp = document.createElement('span');
              let percentage = (expressions[key] * 100).toFixed(1);
              spanExp.textContent = ` ${emotionMapping[key] || key}: ${percentage}%`;
              faceContainer.appendChild(spanExp);
            }
            faceDetailsEl.appendChild(faceContainer);
          });
        } else {
          faceCountSpan.textContent = "Количество лиц: 0";
          let span = document.createElement('span');
          span.textContent = "Лицо не обнаружено";
          faceDetailsEl.appendChild(span);
        }
        // Обновление информации по позе
        poseDetailsEl.innerHTML = "";
        if (pose && pose.keypoints && pose.keypoints.length > 0) {
          pose.keypoints.forEach(keypoint => {
            const spanPose = document.createElement('span');
            spanPose.textContent = `${keypoint.part} (x:${Math.round(keypoint.position.x)}, y:${Math.round(keypoint.position.y)}; score: ${keypoint.score.toFixed(2)})`;
            poseDetailsEl.appendChild(spanPose);
          });
        } else {
          let fallback = getFallbackPose();
          fallback.keypoints.forEach(keypoint => {
            const spanPose = document.createElement('span');
            spanPose.textContent = `${keypoint.part} (x:${Math.round(keypoint.position.x)}, y:${Math.round(keypoint.position.y)}; score: ${keypoint.score.toFixed(2)})`;
            poseDetailsEl.appendChild(spanPose);
          });
        }
      }

      // Обработчики изменения ползунков управления Canvas
      widthSlider.addEventListener('input', () => {
        const newWidth = parseInt(widthSlider.value);
        widthValue.textContent = newWidth;
        canvas.width = newWidth;
        canvas.style.width = newWidth + "px";
      });
      heightSlider.addEventListener('input', () => {
        const newHeight = parseInt(heightSlider.value);
        heightValue.textContent = newHeight;
        canvas.height = newHeight;
        canvas.style.height = newHeight + "px";
      });

      // Основной цикл обработки видео
      async function onPlay() {
        if (video.paused || video.ended) {
          requestAnimationFrame(onPlay);
          return;
        }
        // Настройки детекции
        const faceOptions = new faceapi.TinyFaceDetectorOptions();
        // Всегда запрашиваем landmarks (они понадобятся для режима "маска")
        let faceResults = await faceapi.detectAllFaces(video, faceOptions)
          .withFaceExpressions().withFaceLandmarks();

        let pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: false });
        if (!pose || !pose.keypoints) {
          pose = getFallbackPose();
        }
        // Отрисовка на Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (faceResults && faceResults.length > 0) {
          faceResults.forEach(result => {
            if (faceRenderMode === "рамка") {
              // Рисуем прямоугольник зелёного цвета
              const { x, y, width, height } = result.detection.box;
              ctx.strokeStyle = '#00aa00';
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, width, height);
              // Обновление эмоции для отрисовки
              const expressions = result.expressions;
              const maxValue = Math.max(...Object.values(expressions));
              const detectedEmotionKey = Object.keys(expressions).find(key => expressions[key] === maxValue);
              updateEmotion(detectedEmotionKey);
              ctx.fillStyle = '#00aa00';
              ctx.font = '16px Helvetica';
              const emotionText = emotionMapping[stableEmotion] || 'Определение...';
              ctx.fillText(emotionText, x, y - 10);
            } else if (faceRenderMode === "маска") {
              // Рисуем маску - 68 ключевых точек лица
              if(result.landmarks) {
                faceapi.draw.drawFaceLandmarks(canvas, result.landmarks);
              }
            }
          });
        } else {
          currentEmotion = null;
          stabilityCount = 0;
          stableEmotion = null;
        }
        // Рисуем ключевые точки позы
        if (pose && pose.keypoints && pose.keypoints.length > 0) {
          pose.keypoints.forEach(keypoint => {
            if (keypoint.score > 0.5) {
              ctx.fillStyle = '#4285f4';
              ctx.beginPath();
              ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);
              ctx.fill();
            }
          });
        }
        // Стабилизация обновления данных в панели (раз в 500 мс)
        const now = Date.now();
        if (now - lastPanelUpdate > 500) {
          lastFaceResults = faceResults;
          lastPose = pose;
          updateInfoPanel(lastFaceResults, lastPose);
          lastPanelUpdate = now;
        }
        // Сохранение данных для дальнейшего анализа
        analysisData.push({
          timestamp: Date.now(),
          faces: faceResults,
          pose: pose,
          stableEmotion: stableEmotion
        });
        requestAnimationFrame(onPlay);
      }

      // Инициализация: настройка камеры, загрузка моделей и запуск цикла обработки
      await setupCamera();
      video.play();
      await loadModels();
      onPlay();
    });
  </script>
</body>
</html>
