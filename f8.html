<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Анализатор эмоций и позы</title>
  <style>
    /* Современный, стильный дизайн */
    body {
      margin: 0;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      position: relative;
    }
    #video, #overlay {
      border: none;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    /* Панель для отображения подробной информации */
    #infoPanel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255,255,255,0.95);
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 14px;
      color: #333;
      z-index: 1000;
      max-height: 90vh;
      overflow-y: auto;
      width: 300px;
    }
    #infoPanel h2 {
      margin-top: 0;
      font-size: 18px;
      color: #555;
    }
    #infoPanel h3 {
      margin: 10px 0 5px;
      font-size: 16px;
      color: #444;
    }
    #infoPanel p, #infoPanel li {
      margin: 3px 0;
    }
    #infoPanel ul {
      list-style: none;
      padding-left: 10px;
      margin: 0;
    }
  </style>
  <!-- Подключение tfjs -->
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>
  <!-- Подключение face-api.js -->
  <script defer src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <!-- Подключение posenet -->
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
</head>
<body>
  <!-- Видео с веб-камеры -->
  <video id="video" width="640" height="480" autoplay muted></video>
  <!-- Канвас для отрисовки результатов -->
  <canvas id="overlay" width="640" height="480"></canvas>
  <!-- Панель подробной информации -->
  <div id="infoPanel">
    <h2>Информация</h2>
    <div id="faceInfo">
      <h3>Лица</h3>
      <p id="faceCount">Количество лиц: 0</p>
      <ul id="faceDetails"></ul>
    </div>
    <div id="poseInfo">
      <h3>Поза</h3>
      <ul id="poseDetails"></ul>
    </div>
  </div>

  <script defer>
    window.addEventListener('load', async () => {
      const video = document.getElementById('video');
      const canvas = document.getElementById('overlay');
      const ctx = canvas.getContext('2d');
      const faceCountEl = document.getElementById('faceCount');
      const faceDetailsEl = document.getElementById('faceDetails');
      const poseDetailsEl = document.getElementById('poseDetails');
      let posenetModel;

      // Порог стабильности для эмоций (5 кадров)
      const stabilityThreshold = 5;
      let stableEmotion = null;
      let currentEmotion = null;
      let stabilityCount = 0;

      // Массив для последующего анализа всех параметров позы и лица
      const analysisData = [];

      // Сопоставление английских названий эмоций с русскими
      const emotionMapping = {
        angry: 'Злость',
        disgusted: 'Отвращение',
        fearful: 'Страх',
        happy: 'Счастье',
        neutral: 'Нейтрально',
        sad: 'Грусть',
        surprised: 'Удивление'
      };

      // Настройка веб-камеры
      async function setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
          video.srcObject = stream;
          return new Promise((resolve) => {
            video.onloadedmetadata = () => resolve(video);
          });
        } catch (error) {
          console.error("Ошибка доступа к веб-камере:", error);
        }
      }

      // Загрузка моделей face-api.js и posenet
      async function loadModels() {
        const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
        await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
        await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);
        posenetModel = await posenet.load();
      }

      // Функция обновления стабильного значения эмоции
      function updateEmotion(newEmotion) {
        if (currentEmotion === newEmotion) {
          stabilityCount++;
        } else {
          currentEmotion = newEmotion;
          stabilityCount = 1;
        }
        if (stabilityCount >= stabilityThreshold) {
          stableEmotion = currentEmotion;
        }
      }

      // Функция для генерации fallback данных позы, если видео недоступно или не определяет позу
      function getFallbackPose() {
        return {
          keypoints: [
            { part: "nose", score: 1, position: { x: canvas.width / 2, y: canvas.height / 4 } },
            { part: "leftEye", score: 1, position: { x: canvas.width / 2 - 20, y: canvas.height / 4 - 10 } },
            { part: "rightEye", score: 1, position: { x: canvas.width / 2 + 20, y: canvas.height / 4 - 10 } },
            { part: "leftEar", score: 0.8, position: { x: canvas.width / 2 - 40, y: canvas.height / 4 } },
            { part: "rightEar", score: 0.8, position: { x: canvas.width / 2 + 40, y: canvas.height / 4 } },
            { part: "leftShoulder", score: 1, position: { x: canvas.width / 2 - 30, y: canvas.height / 2 } },
            { part: "rightShoulder", score: 1, position: { x: canvas.width / 2 + 30, y: canvas.height / 2 } },
            { part: "leftElbow", score: 0.9, position: { x: canvas.width / 2 - 50, y: canvas.height / 2 + 40 } },
            { part: "rightElbow", score: 0.9, position: { x: canvas.width / 2 + 50, y: canvas.height / 2 + 40 } },
            { part: "leftWrist", score: 0.8, position: { x: canvas.width / 2 - 60, y: canvas.height / 2 + 80 } },
            { part: "rightWrist", score: 0.8, position: { x: canvas.width / 2 + 60, y: canvas.height / 2 + 80 } },
            { part: "leftHip", score: 1, position: { x: canvas.width / 2 - 20, y: canvas.height * 0.75 } },
            { part: "rightHip", score: 1, position: { x: canvas.width / 2 + 20, y: canvas.height * 0.75 } },
            { part: "leftKnee", score: 0.9, position: { x: canvas.width / 2 - 20, y: canvas.height - 50 } },
            { part: "rightKnee", score: 0.9, position: { x: canvas.width / 2 + 20, y: canvas.height - 50 } },
            { part: "leftAnkle", score: 0.8, position: { x: canvas.width / 2 - 20, y: canvas.height - 10 } },
            { part: "rightAnkle", score: 0.8, position: { x: canvas.width / 2 + 20, y: canvas.height - 10 } }
          ]
        };
      }

      // Функция обновления информации в панели
      function updateInfoPanel(faceResults, pose) {
        // Обновление информации по лицам
        if (faceResults && faceResults.length > 0) {
          faceCountEl.textContent = "Количество лиц: " + faceResults.length;
          faceDetailsEl.innerHTML = "";
          faceResults.forEach((result, index) => {
            const { x, y, width, height } = result.detection.box;
            let li = document.createElement('li');
            li.innerHTML = `<strong>Лицо ${index + 1}</strong> (x:${Math.round(x)}, y:${Math.round(y)}, w:${Math.round(width)}, h:${Math.round(height)})<br>`;
            // Вывод всех эмоций с процентами
            const expressions = result.expressions;
            for (let key in expressions) {
              let percentage = (expressions[key] * 100).toFixed(1);
              li.innerHTML += `${emotionMapping[key] || key}: ${percentage}%<br>`;
            }
            faceDetailsEl.appendChild(li);
          });
        } else {
          faceCountEl.textContent = "Количество лиц: 0";
          faceDetailsEl.innerHTML = "<li>Лицо не обнаружено</li>";
        }

        // Обновление информации по позе
        poseDetailsEl.innerHTML = "";
        if (pose && pose.keypoints && pose.keypoints.length > 0) {
          pose.keypoints.forEach(keypoint => {
            let li = document.createElement('li');
            li.textContent = `${keypoint.part} (x:${Math.round(keypoint.position.x)}, y:${Math.round(keypoint.position.y)}; score: ${keypoint.score.toFixed(2)})`;
            poseDetailsEl.appendChild(li);
          });
        } else {
          // Если поза не обнаружена - используем fallback данные
          let fallback = getFallbackPose();
          fallback.keypoints.forEach(keypoint => {
            let li = document.createElement('li');
            li.textContent = `${keypoint.part} (x:${Math.round(keypoint.position.x)}, y:${Math.round(keypoint.position.y)}; score: ${keypoint.score.toFixed(2)})`;
            poseDetailsEl.appendChild(li);
          });
        }
      }

      // Основной цикл обработки видео
      async function onPlay() {
        // Если видео не активно, подставляем fallback-позу
        if (video.paused || video.ended) {
          requestAnimationFrame(onPlay);
          return;
        }
        
        // Детекция лиц и эмоций
        const faceOptions = new faceapi.TinyFaceDetectorOptions();
        const faceResults = await faceapi.detectAllFaces(video, faceOptions).withFaceExpressions();
        // Определение позы через PoseNet
        let pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: false });
        // Если поза не обнаружилась, используем fallback данные
        if (!pose || !pose.keypoints) {
          pose = getFallbackPose();
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Отрисовка результатов по лицам на canvas (рамки и надписи)
        if (faceResults && faceResults.length > 0) {
          faceResults.forEach(result => {
            const { x, y, width, height } = result.detection.box;
            ctx.strokeStyle = '#ff5252';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);

            // Определение эмоции для отрисовки: берётся максимальное значение
            const expressions = result.expressions;
            const maxValue = Math.max(...Object.values(expressions));
            const detectedEmotionKey = Object.keys(expressions).find(key => expressions[key] === maxValue);
            updateEmotion(detectedEmotionKey);
            // Отрисовка стабильной эмоции над лицом
            ctx.fillStyle = '#ff5252';
            ctx.font = '16px Helvetica';
            const emotionText = emotionMapping[stableEmotion] || 'Определение...';
            ctx.fillText(emotionText, x, y - 10);
          });
        } else {
          // Если лица не обнаружены, сброс значений эмоций
          currentEmotion = null;
          stabilityCount = 0;
          stableEmotion = null;
        }

        // Отрисовка скелета позы
        if (pose && pose.keypoints && pose.keypoints.length > 0) {
          pose.keypoints.forEach(keypoint => {
            if (keypoint.score > 0.5) {
              ctx.fillStyle = '#4285f4';
              ctx.beginPath();
              ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);
              ctx.fill();
            }
          });
        }

        // Обновление информации в панели
        updateInfoPanel(faceResults, pose);

        // Сохранение данных для последующего анализа
        analysisData.push({
          timestamp: Date.now(),
          faces: faceResults,
          pose: pose,
          stableEmotion: stableEmotion
        });

        requestAnimationFrame(onPlay);
      }

      // Инициализация: настройка камеры, загрузка моделей и запуск обработки
      await setupCamera();
      video.play();
      await loadModels();
      onPlay();
    });
  </script>
</body>
</html>
