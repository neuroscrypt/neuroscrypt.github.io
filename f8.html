<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Анализатор эмоций и позы</title>
  <style>
    /* Основной стиль страницы */
    body {
      margin: 0;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
    /* Скрываем видео */
    video#video {
      opacity: 0;
    }
    /* Стили для панели, которая всегда сверху */
    #infoPanel {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 350px;
      height: 630px;
      background: rgba(255,255,255,0.97);
      padding: 10px 15px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 2000;
      overflow-y: auto;
    }
    #infoPanel h2, #infoPanel h3 {
      margin: 5px 0;
      color: #444;
    }
    #infoPanel p, #infoPanel li {
      margin: 3px 0;
      font-size: 14px;
      color: #333;
    }
    #infoPanel ul {
      list-style: none;
      padding-left: 10px;
      margin: 0;
    }
    /* Секция управления размером канваса */
    #canvasControls {
      margin-top: 10px;
    }
    #canvasControls button {
      margin-right: 5px;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
    }
    /* Канвас будем размещать внутри панели */
    #canvasContainer {
      position: relative;
      margin-top: 10px;
      border: 2px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      background: #fff;
      /* стандартный размер канваса */
      width: 640px;
      height: 480px;
      overflow: hidden;
    }
    /* Чтобы канвас занимал всё пространство контейнера */
    canvas#overlay {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
  <!-- Подключение TensorFlow.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>
  <!-- Подключение face-api.js -->
  <script defer src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <!-- Подключение posenet -->
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
</head>
<body>
  <!-- Видео с веб-камеры (скрыто благодаря opacity) -->
  <video id="video" width="640" height="480" autoplay muted></video>

  <!-- Панель с информацией и управлением -->
  <div id="infoPanel">
    <h2>Информация</h2>
    <div id="faceInfo">
      <h3>Лица</h3>
      <p id="faceCount">Количество лиц: 0</p>
      <ul id="faceDetails"></ul>
    </div>
    <div id="poseInfo">
      <h3>Поза</h3>
      <ul id="poseDetails"></ul>
    </div>
    <div id="canvasControls">
      <h3>Управление канвасом</h3>
      <button id="btnStandard">Стандартный (640×480)</button>
      <button id="btnFullscreen">На весь экран</button>
    </div>
    <!-- Контейнер для канваса -->
    <div id="canvasContainer">
      <canvas id="overlay" width="640" height="480"></canvas>
    </div>
  </div>

  <script defer>
    window.addEventListener('load', async () => {
      const video = document.getElementById('video');
      const canvas = document.getElementById('overlay');
      const ctx = canvas.getContext('2d');
      const faceCountEl = document.getElementById('faceCount');
      const faceDetailsEl = document.getElementById('faceDetails');
      const poseDetailsEl = document.getElementById('poseDetails');
      const btnStandard = document.getElementById('btnStandard');
      const btnFullscreen = document.getElementById('btnFullscreen');
      const canvasContainer = document.getElementById('canvasContainer');
      let posenetModel;

      // Порог стабильности для эмоций (5 кадров)
      const stabilityThreshold = 5;
      let stableEmotion = null;
      let currentEmotion = null;
      let stabilityCount = 0;

      // Переменные для стабилизации отображения панели (обновление раз в 500 мс)
      let lastPanelUpdate = Date.now();
      let lastFaceResults = null;
      let lastPose = null;

      // Массив для последующего анализа данных
      const analysisData = [];

      // Сопоставление английских названий эмоций с русскими
      const emotionMapping = {
        angry: 'Злость',
        disgusted: 'Отвращение',
        fearful: 'Страх',
        happy: 'Счастье',
        neutral: 'Нейтрально',
        sad: 'Грусть',
        surprised: 'Удивление'
      };

      // Настройка веб-камеры
      async function setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
          video.srcObject = stream;
          return new Promise((resolve) => {
            video.onloadedmetadata = () => resolve(video);
          });
        } catch (error) {
          console.error("Ошибка доступа к веб-камере:", error);
        }
      }

      // Загрузка моделей face-api.js и posenet
      async function loadModels() {
        const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
        await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
        await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);
        posenetModel = await posenet.load();
      }

      // Функция обновления стабильного значения эмоции
      function updateEmotion(newEmotion) {
        if (currentEmotion === newEmotion) {
          stabilityCount++;
        } else {
          currentEmotion = newEmotion;
          stabilityCount = 1;
        }
        if (stabilityCount >= stabilityThreshold) {
          stableEmotion = currentEmotion;
        }
      }

      // Функция для генерации fallback данных позы, если видео не позволяет определить позу
      function getFallbackPose() {
        return {
          keypoints: [
            { part: "nose", score: 1, position: { x: canvas.width / 2, y: canvas.height / 4 } },
            { part: "leftEye", score: 1, position: { x: canvas.width / 2 - 20, y: canvas.height / 4 - 10 } },
            { part: "rightEye", score: 1, position: { x: canvas.width / 2 + 20, y: canvas.height / 4 - 10 } },
            { part: "leftEar", score: 0.8, position: { x: canvas.width / 2 - 40, y: canvas.height / 4 } },
            { part: "rightEar", score: 0.8, position: { x: canvas.width / 2 + 40, y: canvas.height / 4 } },
            { part: "leftShoulder", score: 1, position: { x: canvas.width / 2 - 30, y: canvas.height / 2 } },
            { part: "rightShoulder", score: 1, position: { x: canvas.width / 2 + 30, y: canvas.height / 2 } },
            { part: "leftElbow", score: 0.9, position: { x: canvas.width / 2 - 50, y: canvas.height / 2 + 40 } },
            { part: "rightElbow", score: 0.9, position: { x: canvas.width / 2 + 50, y: canvas.height / 2 + 40 } },
            { part: "leftWrist", score: 0.8, position: { x: canvas.width / 2 - 60, y: canvas.height / 2 + 80 } },
            { part: "rightWrist", score: 0.8, position: { x: canvas.width / 2 + 60, y: canvas.height / 2 + 80 } },
            { part: "leftHip", score: 1, position: { x: canvas.width / 2 - 20, y: canvas.height * 0.75 } },
            { part: "rightHip", score: 1, position: { x: canvas.width / 2 + 20, y: canvas.height * 0.75 } },
            { part: "leftKnee", score: 0.9, position: { x: canvas.width / 2 - 20, y: canvas.height - 50 } },
            { part: "rightKnee", score: 0.9, position: { x: canvas.width / 2 + 20, y: canvas.height - 50 } },
            { part: "leftAnkle", score: 0.8, position: { x: canvas.width / 2 - 20, y: canvas.height - 10 } },
            { part: "rightAnkle", score: 0.8, position: { x: canvas.width / 2 + 20, y: canvas.height - 10 } }
          ]
        };
      }

      // Функция обновления информации в панели (вызывается раз в 500 мс)
      function updateInfoPanel(faceResults, pose) {
        // Лица
        if (faceResults && faceResults.length > 0) {
          faceCountEl.textContent = "Количество лиц: " + faceResults.length;
          faceDetailsEl.innerHTML = "";
          faceResults.forEach((result, index) => {
            const { x, y, width, height } = result.detection.box;
            let li = document.createElement('li');
            li.innerHTML = `<strong>Лицо ${index + 1}</strong> (x:${Math.round(x)}, y:${Math.round(y)}, w:${Math.round(width)}, h:${Math.round(height)})<br>`;
            const expressions = result.expressions;
            for (let key in expressions) {
              let percentage = (expressions[key] * 100).toFixed(1);
              li.innerHTML += `${emotionMapping[key] || key}: ${percentage}%<br>`;
            }
            faceDetailsEl.appendChild(li);
          });
        } else {
          faceCountEl.textContent = "Количество лиц: 0";
          faceDetailsEl.innerHTML = "<li>Лицо не обнаружено</li>";
        }
        // Поза
        poseDetailsEl.innerHTML = "";
        if (pose && pose.keypoints && pose.keypoints.length > 0) {
          pose.keypoints.forEach(keypoint => {
            let li = document.createElement('li');
            li.textContent = `${keypoint.part} (x:${Math.round(keypoint.position.x)}, y:${Math.round(keypoint.position.y)}; score: ${keypoint.score.toFixed(2)})`;
            poseDetailsEl.appendChild(li);
          });
        } else {
          let fallback = getFallbackPose();
          fallback.keypoints.forEach(keypoint => {
            let li = document.createElement('li');
            li.textContent = `${keypoint.part} (x:${Math.round(keypoint.position.x)}, y:${Math.round(keypoint.position.y)}; score: ${keypoint.score.toFixed(2)})`;
            poseDetailsEl.appendChild(li);
          });
        }
      }

      // Обработчики для изменения размера канваса
      btnStandard.addEventListener('click', () => {
        canvasContainer.style.width = '640px';
        canvasContainer.style.height = '480px';
        canvas.width = 640;
        canvas.height = 480;
      });
      btnFullscreen.addEventListener('click', () => {
        // Занимаем почти весь экран панели
        canvasContainer.style.width = '100%';
        canvasContainer.style.height = '100%';
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
      });

      // Основной цикл обработки видео
      async function onPlay() {
        // Если видео не активно, пропускаем отрисовку
        if (video.paused || video.ended) {
          requestAnimationFrame(onPlay);
          return;
        }
        
        const faceOptions = new faceapi.TinyFaceDetectorOptions();
        const faceResults = await faceapi.detectAllFaces(video, faceOptions).withFaceExpressions();
        let pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: false });
        if (!pose || !pose.keypoints) {
          pose = getFallbackPose();
        }

        // Отрисовка графики на канвасе
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (faceResults && faceResults.length > 0) {
          faceResults.forEach(result => {
            const { x, y, width, height } = result.detection.box;
            ctx.strokeStyle = '#ff5252';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            const expressions = result.expressions;
            const maxValue = Math.max(...Object.values(expressions));
            const detectedEmotionKey = Object.keys(expressions).find(key => expressions[key] === maxValue);
            updateEmotion(detectedEmotionKey);
            ctx.fillStyle = '#ff5252';
            ctx.font = '16px Helvetica';
            const emotionText = emotionMapping[stableEmotion] || 'Определение...';
            ctx.fillText(emotionText, x, y - 10);
          });
        } else {
          currentEmotion = null;
          stabilityCount = 0;
          stableEmotion = null;
        }
        if (pose && pose.keypoints && pose.keypoints.length > 0) {
          pose.keypoints.forEach(keypoint => {
            if (keypoint.score > 0.5) {
              ctx.fillStyle = '#4285f4';
              ctx.beginPath();
              ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);
              ctx.fill();
            }
          });
        }
        
        // Для стабилизации обновления панели – обновляем только раз в 500 мс
        const now = Date.now();
        if (now - lastPanelUpdate > 500) {
          lastFaceResults = faceResults;
          lastPose = pose;
          updateInfoPanel(lastFaceResults, lastPose);
          lastPanelUpdate = now;
        }

        // Сохранение данных для дальнейшего анализа
        analysisData.push({
          timestamp: Date.now(),
          faces: faceResults,
          pose: pose,
          stableEmotion: stableEmotion
        });

        requestAnimationFrame(onPlay);
      }

      // Инициализация: настройка камеры, загрузка моделей и запуск цикла обработки
      await setupCamera();
      video.play();
      await loadModels();
      onPlay();
    });
  </script>
</body>
</html>
