<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Анализатор эмоций и поз</title>
  <style>
    body {
      margin: 0;
      background: #f0f2f5;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    #video {
      position: absolute;
      opacity: 0;
    }
    #overlay {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }
    #panel {
      position: absolute;
      right: 0;
      top: 0;
      width: 350px;
      height: 870px;
      background-color: #ffffffcc;
      padding: 16px;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      z-index: 2;
      overflow-y: auto;
    }
    .info {
      margin: 8px 0;
    }
    .info span.label {
      font-weight: bold;
    }
    .slider {
      width: 100%;
    }
    .toggle-btn {
      margin-top: 10px;
    }
  </style>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>
  <script defer src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
</head>
<body>
  <video id="video" width="1280" height="960" autoplay muted></video>
  <canvas id="overlay" width="1280" height="960"></canvas>

  <div id="panel">
    <div class="info"><span class="label">Эмоция:</span> <span id="emotion"></span></div>
    <div class="info"><span class="label">Поза:</span> <span id="poseStatus">Ожидание...</span></div>
    <div class="info"><span class="label">Нос:</span> <span id="nose"></span></div>
    <div class="info"><span class="label">Левое плечо:</span> <span id="leftShoulder"></span></div>
    <div class="info"><span class="label">Правое плечо:</span> <span id="rightShoulder"></span></div>
    <div class="toggle-btn">
      <button id="toggleRender">Переключить рамку/маску</button>
    </div>
    <div class="slider">
      <label for="canvasWidth">Ширина Canvas</label>
      <input type="range" id="canvasWidth" min="640" max="1920" value="1280">
    </div>
    <div class="slider">
      <label for="canvasHeight">Высота Canvas</label>
      <input type="range" id="canvasHeight" min="480" max="1080" value="960">
    </div>
  </div>

  <script>
    const emotionMapping = {
      happy: "Счастье",
      sad: "Грусть",
      angry: "Злость",
      fearful: "Страх",
      disgusted: "Отвращение",
      surprised: "Удивление",
      neutral: "Нейтральное"
    };

    let video = document.getElementById('video');
    let canvas = document.getElementById('overlay');
    let ctx = canvas.getContext('2d');
    let faceRenderMode = "рамка";
    let stableEmotion = null;
    let currentEmotion = null;
    let stabilityCount = 0;
    let lastPanelUpdate = 0;
    let posenetModel;

    document.getElementById("toggleRender").onclick = () => {
      faceRenderMode = faceRenderMode === "рамка" ? "маска" : "рамка";
    };

    document.getElementById('canvasWidth').addEventListener('input', (e) => {
      canvas.width = parseInt(e.target.value);
    });
    document.getElementById('canvasHeight').addEventListener('input', (e) => {
      canvas.height = parseInt(e.target.value);
    });

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
      video.srcObject = stream;
      return new Promise(resolve => {
        video.onloadedmetadata = () => resolve(video);
      });
    }

    function updateEmotion(detected) {
      if (currentEmotion === detected) {
        stabilityCount++;
        if (stabilityCount >= 5) {
          stableEmotion = detected;
        }
      } else {
        currentEmotion = detected;
        stabilityCount = 0;
      }
    }

    function updateInfoPanel(faces, pose) {
      document.getElementById('emotion').innerText = stableEmotion ? emotionMapping[stableEmotion] : 'Не определено';
      document.getElementById('poseStatus').innerText = pose ? 'Обнаружена' : 'Не обнаружена';
      if (pose) {
        document.getElementById('nose').innerText = `${pose.keypoints[0].position.x.toFixed(0)}, ${pose.keypoints[0].position.y.toFixed(0)}`;
        document.getElementById('leftShoulder').innerText = `${pose.keypoints[5].position.x.toFixed(0)}, ${pose.keypoints[5].position.y.toFixed(0)}`;
        document.getElementById('rightShoulder').innerText = `${pose.keypoints[6].position.x.toFixed(0)}, ${pose.keypoints[6].position.y.toFixed(0)}`;
      }
    }

    async function onPlay() {
      if (video.paused || video.ended) {
        requestAnimationFrame(onPlay);
        return;
      }

      const faceOptions = new faceapi.TinyFaceDetectorOptions();
      let faceResults = await faceapi.detectAllFaces(video, faceOptions)
        .withFaceLandmarks()
        .withFaceExpressions();

      let pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: false });

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (faceResults && faceResults.length > 0) {
        faceResults.forEach(result => {
          const { x, y, width, height } = result.detection.box;
          const expressions = result.expressions;
          const maxValue = Math.max(...Object.values(expressions));
          const emotionKey = Object.keys(expressions).find(k => expressions[k] === maxValue);
          updateEmotion(emotionKey);

          if (faceRenderMode === "рамка") {
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            ctx.fillStyle = 'green';
            ctx.font = '18px Segoe UI';
            ctx.fillText(emotionMapping[stableEmotion] || '', x, y - 10);
          } else {
            faceapi.draw.drawFaceLandmarks(canvas, result);
          }
        });
      }

      if (pose && pose.keypoints) {
        pose.keypoints.forEach(kp => {
          if (kp.score > 0.5) {
            ctx.beginPath();
            ctx.arc(kp.position.x, kp.position.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#4285f4';
            ctx.fill();
          }
        });
      }

      if (Date.now() - lastPanelUpdate > 500) {
        updateInfoPanel(faceResults, pose);
        lastPanelUpdate = Date.now();
      }

      requestAnimationFrame(onPlay);
    }

    async function init() {
      await setupCamera();
      video.play();

      const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
      await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
      await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
      await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);

      posenetModel = await posenet.load();
      onPlay();
    }

    init();
  </script>
</body>
</html>
