<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Робот Судья</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #eceff4;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* Робот сидит в правом нижнем углу, как виджет */
    #robot-wrapper {
      position: fixed;
      right: 40px;
      bottom: 40px;
      width: 260px;
      height: 260px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* чтобы не мешал кликам по странице */
    }

    canvas {
      width: 220px;
      height: 220px;
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
  </style>
</head>
<body>

<div id="robot-wrapper">
  <canvas id="robotCanvas" width="220" height="220"></canvas>
</div>

<script>
  // --- Базовая настройка canvas с учётом HiDPI -----------------------------

  const canvas = document.getElementById('robotCanvas');
  const ctx = canvas.getContext('2d');

  function setupCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const logicalSize = 220;           // "логический" размер в CSS-пикселях
    canvas.style.width  = logicalSize + 'px';
    canvas.style.height = logicalSize + 'px';
    canvas.width  = logicalSize * dpr;
    canvas.height = logicalSize * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // масштабируем систему координат
  }

  setupCanvas();
  window.addEventListener('resize', setupCanvas);

  const W = 220;
  const H = 220;

  // --- Вспомогательные функции рисования -----------------------------------

  function roundedRectPath(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.lineTo(x + w - rr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
    ctx.lineTo(x + w, y + h - rr);
    ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
    ctx.lineTo(x + rr, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
    ctx.lineTo(x, y + rr);
    ctx.quadraticCurveTo(x, y, x + rr, y);
    ctx.closePath();
  }

  // --- Параметры анимации робота -------------------------------------------

  let startTime = performance.now();
  let eyeOpen = 1;           // 1 — глаза полностью открыты, 0 — закрыты
  let blinking = false;
  let blinkStart = 0;
  let nextBlinkTime = 0;

  const BLINK_DURATION = 0.25; // секунд на "закрыл/открыл"

  function scheduleNextBlink(nowSeconds) {
    // следующее моргание через 1–4 секунды
    nextBlinkTime = nowSeconds + 1 + Math.random() * 3;
  }

  scheduleNextBlink(0);

  // --- Обновление состояния моргания ---------------------------------------

  function updateBlink(t) {
    if (!blinking && t >= nextBlinkTime) {
      blinking = true;
      blinkStart = t;
    }

    if (blinking) {
      const progress = (t - blinkStart) / BLINK_DURATION;

      if (progress >= 1) {
        blinking = false;
        eyeOpen = 1;
        scheduleNextBlink(t);
      } else {
        // фазу делаем "туда-обратно": открыто → закрыто → открыто
        const phase = progress < 0.5 ? progress * 2 : (1 - progress) * 2;
        eyeOpen = 1 - phase; // 1..0..1
      }
    }
  }

  // --- Основная функция рисования робота-судьи -----------------------------

  function drawRobot(t) {
    ctx.clearRect(0, 0, W, H);

    ctx.save();
    ctx.translate(W / 2, H / 2);

    // Плавание вверх-вниз (имитация левитации)
    const floatAmplitude = 6;
    const floatY = Math.sin(t * 2) * floatAmplitude;
    ctx.translate(0, floatY);

    // Тень под роботом
    const shadowY = 64;
    const shadowRadiusX = 42;
    const shadowRadiusY = 10;
    const shadowGradient = ctx.createRadialGradient(
      0, shadowY, 5,
      0, shadowY, shadowRadiusX
    );
    shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.25)');
    shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = shadowGradient;
    ctx.beginPath();
    ctx.ellipse(0, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
    ctx.fill();

    // Корпус+голова
    const bodyWidth = 80;
    const bodyHeight = 90;
    const bodyX = -bodyWidth / 2;
    const bodyY = -80;

    // Лёгкий градиент корпуса
    const bodyGrad = ctx.createLinearGradient(0, bodyY, 0, bodyY + bodyHeight);
    bodyGrad.addColorStop(0, '#ffffff');
    bodyGrad.addColorStop(0.4, '#f0f4ff');
    bodyGrad.addColorStop(1, '#d6e2ff');

    ctx.fillStyle = bodyGrad;
    ctx.strokeStyle = '#c3d0f5';
    ctx.lineWidth = 2;

    roundedRectPath(bodyX, bodyY, bodyWidth, bodyHeight, 20);
    ctx.fill();
    ctx.stroke();

    // "Юридическая" мантия (тёмная накидка)
    const robeWidth = 96;
    const robeHeight = 64;
    const robeX = -robeWidth / 2;
    const robeY = bodyY + 20;
    const robeGrad = ctx.createLinearGradient(robeX, robeY, robeX, robeY + robeHeight);
    robeGrad.addColorStop(0, '#1c2437');
    robeGrad.addColorStop(1, '#131826');
    ctx.fillStyle = robeGrad;

    roundedRectPath(robeX, robeY, robeWidth, robeHeight, 26);
    ctx.fill();

    // Белый "воротник" судьи
    ctx.fillStyle = '#f9fbff';
    roundedRectPath(-18, robeY + 6, 36, 26, 10);
    ctx.fill();

    // Маленькая золотая эмблема (весы правосудия в упрощённом виде)
    ctx.save();
    ctx.translate(0, robeY + 30);
    ctx.strokeStyle = '#f5c55f';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10, 0);
    ctx.lineTo(10, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, -8);
    ctx.lineTo(0, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-10, 0);
    ctx.lineTo(-16, 6);
    ctx.moveTo(10, 0);
    ctx.lineTo(16, 6);
    ctx.stroke();
    ctx.restore();

    // Голова (немного шире корпуса) + панель лица
    const headWidth = 86;
    const headHeight = 60;
    const headX = -headWidth / 2;
    const headY = bodyY - 40;

    const headGrad = ctx.createLinearGradient(0, headY, 0, headY + headHeight);
    headGrad.addColorStop(0, '#ffffff');
    headGrad.addColorStop(0.3, '#f7fbff');
    headGrad.addColorStop(1, '#dde7ff');

    ctx.fillStyle = headGrad;
    ctx.strokeStyle = '#c3d0f5';
    ctx.lineWidth = 2;
    roundedRectPath(headX, headY, headWidth, headHeight, 22);
    ctx.fill();
    ctx.stroke();

    // Лицо-панель
    const faceX = headX + 10;
    const faceY = headY + 14;
    const faceWidth = headWidth - 20;
    const faceHeight = 26;
    const faceGrad = ctx.createLinearGradient(faceX, faceY, faceX, faceY + faceHeight);
    faceGrad.addColorStop(0, '#1c2335');
    faceGrad.addColorStop(1, '#0f1524');

    ctx.fillStyle = faceGrad;
    roundedRectPath(faceX, faceY, faceWidth, faceHeight, 14);
    ctx.fill();

    // Глаза (два круглых индикатора)
    const eyeRadius = 5;
    const eyeY = faceY + faceHeight / 2;
    const eyeOffsetX = 14;

    // глаз "по вертикали" сжимается при моргании
    const eyeH = eyeRadius * eyeOpen;
    ctx.fillStyle = '#73d7ff';

    function drawEye(cx) {
      ctx.save();
      ctx.translate(cx, eyeY);
      ctx.beginPath();
      ctx.scale(1, Math.max(0.2, eyeOpen)); // чтобы закрытый глаз был тонкой линией
      ctx.arc(0, 0, eyeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    drawEye(-eyeOffsetX);
    drawEye(eyeOffsetX);

    // Небольшая "улыбка" светлой линией
    ctx.strokeStyle = '#4ec0ff';
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.arc(0, eyeY + 8, 10, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();

    // Судейский парик (упрощённо – светлые сегменты вокруг головы)
    ctx.save();
    ctx.strokeStyle = '#e5ecff';
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    const wigY = headY + 12;
    ctx.beginPath();
    ctx.moveTo(headX + 12, wigY);
    ctx.lineTo(headX + 12, wigY + 26);
    ctx.moveTo(headX + headWidth - 12, wigY);
    ctx.lineTo(headX + headWidth - 12, wigY + 26);
    ctx.stroke();
    ctx.restore();

    // Руки-манипуляторы
    const armY = robeY + 18;
    const armLength = 32;

    // Левая рука (держит весы)
    ctx.save();
    ctx.strokeStyle = '#c3d0f5';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.translate(-bodyWidth / 2, armY);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-armLength, 6);
    ctx.stroke();

    // Простые "весы": перекладина + две чаши
    ctx.translate(-armLength, 6);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#f5c55f';
    ctx.beginPath();
    ctx.moveTo(-10, 0);
    ctx.lineTo(10, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-10, 0);
    ctx.lineTo(-10, 10);
    ctx.moveTo(10, 0);
    ctx.lineTo(10, 10);
    ctx.stroke();

    ctx.fillStyle = 'rgba(245,197,95,0.85)';
    ctx.beginPath();
    ctx.arc(-10, 12, 4, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(10, 12, 4, Math.PI, 0);
    ctx.fill();

    ctx.restore();

    // Правая рука с молотком, слегка раскачивающаяся
    ctx.save();
    const hammerSwing = Math.sin(t * 3) * 0.3; // радианы
    ctx.translate(bodyWidth / 2, armY);
    ctx.rotate(0.2 + hammerSwing);

    // рука
    ctx.strokeStyle = '#c3d0f5';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(armLength, 0);
    ctx.stroke();

    // молоток
    ctx.translate(armLength, 0);
    ctx.strokeStyle = '#8b5a2b';
    ctx.fillStyle = '#b47b3c';

    // ручка
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(12, 0);
    ctx.stroke();

    // "шляпка" молотка
    roundedRectPath(10, -6, 12, 12, 3);
    ctx.fill();
    ctx.stroke();

    ctx.restore();

    ctx.restore();

    // Лёгкие "искры" вокруг головы (чуть-чуть глоу, чтобы смотрелось живее)
    ctx.save();
    const sparkCount = 5;
    ctx.fillStyle = 'rgba(115, 215, 255, 0.6)';
    for (let i = 0; i < sparkCount; i++) {
      const angle = (t * 0.6 + i * 1.3) % (Math.PI * 2);
      const radius = 70 + 4 * Math.sin(t * 2 + i);
      const x = W / 2 + Math.cos(angle) * radius;
      const y = H / 2 - 40 + Math.sin(angle) * radius * 0.5;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // --- Главный цикл анимации -----------------------------------------------

  function loop(now) {
    const t = (now - startTime) / 1000; // секунды
    updateBlink(t);
    drawRobot(t);
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>

</body>
</html>
